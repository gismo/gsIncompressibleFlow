/** @file flappingBeam_fluid.cpp
 
    This file is part of the G+Smo library.

    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.

    Author(s): J. Li
*/


#include <gismo.h>
#include <map>

#include <gsIncompressibleFlow/src/gsINSSolver.h>
#include <gsIncompressibleFlow/src/gsFlowUtils.h>
#include <gsIncompressibleFlow/src/gsFlowBndEvaluators.h>
#include <gsHLBFGS/gsHLBFGS.h>
#include <gsElasticity/src/gsElasticityAssembler.h>
#include <gsElasticity/src/gsLinearMaterial.h>
#include <gsElasticity/src/gsMassAssembler.h>
#include <gsElasticity/src/gsElTimeIntegrator.h>

// 添加 gsLookupFunction 的路径
#include <gsPreCICE/gsLookupFunction.h>
// #include "../../gsPreCICE/gsLookupFunction.h"

// 添加 B-spline 相关头文件
#include <gsNurbs/gsBSplineBasis.h>
#include <gsNurbs/gsBSpline.h>
#include <gsUtils/gsL2Projection.h>

using namespace gismo;

// 前向声明
struct FluidInterface{
    size_t patchIdx;
    boundary::side boundarySide;
};

// 全局变量用于存储边界速度
static std::map<int, gsMatrix<real_t>> boundaryVelocities;

// 全局变量用于梁动画保存
static gsParaviewCollection beamDispCollection("beam_displacement_animation");
static gsParaviewCollection beamStressCollection("beam_stress_animation");
static bool beamAnimationInitialized = false;

// 压力到牵引力转换类
template<class T>
class gsPressureToTraction : public gsFunction<T>
{
public:
    gsPressureToTraction(const gsFunction<T>& pressureFunc, 
                        const gsGeometry<T>& patchGeom,
                        boundary::side side)
        : m_pressureFunc(pressureFunc.clone()), 
          m_patchGeom(patchGeom.clone()), 
          m_side(side) 
    {
        m_boundaryGeom = m_patchGeom->boundary(m_side);
        
        // 调试输出：显示初始化信息
        gsInfo << "[gsPressureToTraction] Initialized for side " << m_side << "\n";
        gsInfo << "  Patch geometry: domainDim=" << m_patchGeom->domainDim() 
               << ", targetDim=" << m_patchGeom->targetDim() << "\n";
        gsInfo << "  Boundary geometry: domainDim=" << m_boundaryGeom->domainDim() 
               << ", targetDim=" << m_boundaryGeom->targetDim() << "\n";
        gsInfo << "  Pressure function: domainDim=" << m_pressureFunc->domainDim() 
               << ", targetDim=" << m_pressureFunc->targetDim() << "\n";
    }
    
    short_t domainDim() const override { return 2; } // 接受2D patch参数
    short_t targetDim() const override { return 2; } // 输出2D牵引力向量
    
    // 使用patch几何计算边界法向量（接受2D patch参数）
    gsVector<T> computeNormalWithExpr(const gsMatrix<T>& patchParam) const
    {
        // 使用整个patch的基函数
        gsMultiBasis<T> basis(*m_patchGeom);
        
        // 创建表达式汇编器
        gsExprAssembler<T> A(1,1);
        A.setIntegrationElements(basis);
        gsExprEvaluator<T> ev(A);
        
        // 获取patch几何映射
        auto G = ev.getMap(*m_patchGeom);
        
        // 将2D patch参数转换为边界上的参数
        gsMatrix<T> boundaryParam = patchParam;
        
        // // 确保参数点在边界上
        // switch (m_side) {
        //     case boundary::north:
        //         boundaryParam(1, 0) = 1.0;  // v = 1
        //         break;
        //     case boundary::south:
        //         boundaryParam(1, 0) = 0.0;  // v = 0
        //         break;
        //     case boundary::east:
        //         boundaryParam(0, 0) = 1.0;  // u = 1
        //         break;
        //     case boundary::west:
        //         boundaryParam(0, 0) = 0.0;  // u = 0
        //         break;
        // }
        
        // 在边界点计算法向量
        gsMatrix<T> normal = ev.eval(nv(G).normalized(), boundaryParam);

        gsMatrix<T> binormal(normal.rows(), normal.cols());

        gsInfo << normal.dim() << "\n";

        binormal.row(0) = -normal.row(1); // 交换行
        binormal.row(1) = normal.row(0); // 反转第二行

        
        // 对于梁的边界，我们需要调整法向量方向
        // 流体施加到固体的压力应该指向固体内部
        // 所以需要反转外法向量

        // 调试输出：显示参数和法向量
        gsInfo << "[computeNormalWithExpr] Side: " << m_side 
               << ", Original param: " << patchParam.transpose()
               << ", Boundary param: " << boundaryParam.transpose() 
               << ", Normal (inward): " << normal.transpose() << "\n";
        
        return binormal.col(0); // 返回第一个法向量分量
    }
    
    void eval_into(const gsMatrix<T>& u, gsMatrix<T>& result) const override
    {
        result.resize(2, u.cols());
        
        for (index_t i = 0; i < u.cols(); ++i) {
            // u.col(i) 是2D patch参数点
            gsMatrix<T> paramPoint = u.col(i);
            
            // 直接在参数空间评估压力（如果压力函数定义在参数域）
            // 注意：这里假设压力函数可能定义在物理域或参数域
            gsMatrix<T> pressure;
            if (m_pressureFunc->domainDim() == 2 && m_pressureFunc->targetDim() == 1) {
                // 压力函数定义在参数域（IGA-IGA耦合情况）
                m_pressureFunc->eval_into(paramPoint, pressure);
            } else {
                // 压力函数定义在物理域（原始情况）
                gsMatrix<T> physicalPoint;
                m_patchGeom->eval_into(paramPoint, physicalPoint);
                m_pressureFunc->eval_into(physicalPoint, pressure);
            }
            
            // 使用gsExprAssembler方法计算法向量
            gsVector<T> normal = computeNormalWithExpr(paramPoint);

            // 调试输出：显示参数点、压力和法向量
            gsInfo << "[eval_into] Point " << i << ": paramPoint=" << paramPoint.transpose() 
                   << ", pressure=" << pressure(0, 0) 
                   << ", normal=" << normal.transpose() 
                   << ", traction=[" << -pressure(0, 0) * normal(0) << ", " << -pressure(0, 0) * normal(1) << "]\n";
            
            // 牵引力 = -压力 * 法向量
            result(0, i) = -pressure(0, 0) * normal(0);
            result(1, i) = -pressure(0, 0) * normal(1);
        }
    }
    
    gsFunction<T>* clone() const {
        return new gsPressureToTraction<T>(*m_pressureFunc, *m_boundaryGeom, m_side);
    }
    
private:
    std::unique_ptr<gsFunction<T>> m_pressureFunc;
    std::unique_ptr<gsGeometry<T>> m_patchGeom;
    std::unique_ptr<gsGeometry<T>> m_boundaryGeom;
    boundary::side m_side;
};

template<class T, int MatOrder> void solveProblem(gsINSSolver<T, MatOrder>& NSsolver, gsOptionList opt, int geo);

// reset the solver with a new mesh
template<class T, int MatOrder>
void resetSolverWithNewMesh(gsINSSolverUnsteady<T, MatOrder>*& solver,
                            const gsMultiPatch<T>& newPatches,
                            const gsMultiPatch<T>* velocityWithBoundary = nullptr);

// transfer the solution to a new mesh
template<class T, int MatOrder>
void transferSolutionToNewMesh(gsINSSolverUnsteady<T, MatOrder>* solver,
                              const gsField<T>& velocityField,
                              const gsField<T>& pressureField,
                              const gsMultiPatch<T>* velocityWithBoundary = nullptr);

// // 根据时间更新几何体边界
// template<class T>
// void updateGeometryBoundary(gsMultiPatch<T>& patches, T time,
//                            const std::vector<FluidInterface>& interfaces);

// 根据固体位移更新几何体边界
template<class T>
void updateGeometryBoundaryFromSolid(gsMultiPatch<T>& patches, 
                                     const gsMultiPatch<T>& solidDisplacement,
                                     const std::vector<FluidInterface>& interfaces,
                                     const gsMultiPatch<T>& initialFluidGeometry,
                                     const gsMultiPatch<T>& solidReferenceGeometry);

// 根据固体速度更新流体边界速度
template<class T>
void updateFluidBoundaryVelocityFromSolid(gsMultiPatch<T>& fluidVelocity,
                                          const gsMultiPatch<T>& fluidGeometry,
                                          const gsMultiPatch<T>& solidVelocity,
                                          const gsMultiPatch<T>& solidReferenceGeometry,
                                          const gsMultiPatch<T>& solidDisplacement,
                                          const std::vector<FluidInterface>& interfaces);

// 从求解器提取速度场为 gsMultiPatch
template<class T, int MatOrder>
void extractVelocityMultiPatch(gsINSSolverUnsteady<T, MatOrder>& solver,
                              gsMultiPatch<T>& velocityMP);

int main(int argc, char *argv[])
{
    typedef gsGMRes<real_t> LinSolver;

    // ========================================= Settings ========================================= 

    // solvers
    bool steady = false;
    bool steadyIt = false;
    bool unsteady = false;
    bool unsteadyIt = false;

    // domain definition
    int geo = 1; // 0 - custom input file, 1 - step, 2 - cavity, 3 - blade profile 2D, 4 - flapping beam
    int dim = 2; // relevant for step and cavity
    std::string inputFile = "";
    
    // discretization settings
    int numRefine = 3;
    int wallRefine = 0; // relevant for step, cavity, profile2D
    int leadRefine = 0; // relevant for profile2D
    int numElevate = 0; // number of degree elevations (before refinement)

    // problem parameters
    real_t viscosity = 0.1;
    real_t inVelX = 1; // inlet x-velocity for profile2D
    real_t inVelY = 0; // inlet y-velocity for profile2D
    
    // 结构参数
    real_t youngsModulus = 1.4e6;
    real_t poissonsRatio = 0.4;
    real_t solidDensity = 1.0e3;
    
    // solver settings
    int maxIt = 5;
    int picardIt = 5;
    int linIt = 50;
    real_t timeStep = 0.01;
    real_t tol = 1e-5;
    real_t picardTol = 1e-4;
    real_t linTol = 1e-6;
    std::string matFormation = "EbE";
    std::string precond = "MSIMPLER_FdiagEqual";
    bool stokesInit = false; // start unsteady problem from Stokes solution

    // output settings
    bool quiet = false;
    bool plot = false;
    bool plotMesh = false;
    int plotPts = 1000;
    bool animation = false;
    int animStep = 100;

    // ---------------------------------------------------------------------------------

    //command line
    gsCmdLine cmd("Solves the Navier-Stokes problem in a given domain (step, cavity, blade profile).");

    cmd.addSwitch("steady", "Solve steady problem with direct linear solver", steady);
    cmd.addSwitch("steadyIt", "Solve steady problem with preconditioned GMRES as linear solver", steadyIt);
    cmd.addSwitch("unsteady", "Solve unsteady problem with direct linear solver", unsteady);
    cmd.addSwitch("unsteadyIt", "Solve unsteady problem with preconditioned GMRES as linear solver", unsteadyIt);

    cmd.addInt("g", "geo", "Computational domain (0 - custom file, 1 - step, 2 - cavity, 3 - profile (only 2D), 4 - flapping beam)", geo);
    cmd.addInt("d", "dim", "Space dimension", dim);
    cmd.addString("", "input", "Full path to the input xml file containing geometry, right-hand side functin and boundary conditions", inputFile);

    cmd.addInt("r", "uniformRefine", "Number of uniform h-refinement steps to perform before solving", numRefine);
    cmd.addInt("", "wallRefine", "Number of h-refinement steps near step corner, cavity walls of blade profile", wallRefine);
    cmd.addInt("", "leadRefine", "Number of h-refinement steps near the beginning of the blade (for profile geometry)", leadRefine);
    cmd.addInt("e", "degElevate", "Number of degree elevations (performed before h-refinement)", numElevate);

    cmd.addReal("v", "visc", "Viscosity value", viscosity);
    cmd.addReal("", "inVelX", "x-coordinate of inflow velocity (for profile geometry)", inVelX);
    cmd.addReal("", "inVelY", "y-coordinate of inflow velocity (for profile geometry)", inVelY);

    cmd.addInt("", "maxIt", "Max. number of Picard iterations or time steps", maxIt);
    cmd.addInt("", "picardIt", "Max. number of inner Picard iterations for unsteady problem", picardIt);
    cmd.addInt("", "linIt", "Max. number of GMRES iterations (if the lin. systems are solved iteratively)", linIt);
    cmd.addReal("", "timeStep", "Time discretization step for unsteady problem", timeStep);
    cmd.addReal("", "tol", "Stopping tolerance", tol);
    cmd.addReal("", "picardTol", "Tolerance for inner Picard iteration for unsteady problem", picardTol);
    cmd.addReal("", "linTol", "Tolerance for iterative linear solver", linTol);
    cmd.addString("", "loop", "Matrix formation method (EbE = element by element, RbR = row by row)", matFormation);
    cmd.addString("p", "precond", "Preconditioner type (format: PREC_Fstrategy, PREC = {PCD, PCDmod, LSC, AL, SIMPLE, SIMPLER, MSIMPLER}, Fstrategy = {FdiagEqual, Fdiag, Fmod, Fwhole})", precond);
    cmd.addSwitch("stokesInit", "Set Stokes initial condition", stokesInit);

    cmd.addSwitch("quiet", "Supress (some) terminal output", quiet);
    cmd.addSwitch("plot", "Plot the final result in ParaView format", plot);
    cmd.addSwitch("plotMesh", "Plot the computational mesh", plotMesh);
    cmd.addInt("", "plotPts", "Number of sample points for plotting", plotPts);
    cmd.addSwitch("animation", "Plot animation of the unsteady problem", animation);
    cmd.addInt("", "animStep", "Number of iterations between screenshots for animation (used when animation = true)", animStep);

    try { cmd.getValues(argc, argv); } catch (int rv) { return rv; }

    if (!inputFile.empty())
        geo = 0;

    if ( !(steady || steadyIt || unsteady || unsteadyIt) )
        gsWarn << "All computation flags set to false - nothing will be computed.\nPlease select at least one of the flags: --steady, --steadyIt, --unsteady, --unsteadyIt\n\n";

    // ========================================= Define problem (geometry, BCs, rhs) ========================================= 
    
    gsMultiPatch<> patches;
    gsBoundaryConditions<> bcInfo;
    gsFunctionExpr<> f; // external force

    std::string fn, geoStr;

    switch(geo)
    {
        case 0:
            break; // inputFile is given from cmd
        
        default:
            gsWarn << "Unknown geometry ID, using backward-facing step.\n";
            geo = 1;

        case 1:
            geoStr = "BFS" + util::to_string(dim) + "D";
            fn = geoStr + "_problem.xml";
            inputFile = fn;
            break;

        case 2:
            geoStr = "LDC" + util::to_string(dim) + "D";
            fn = geoStr + "_problem.xml";
            inputFile = fn;
            break;

        case 3:
            if (dim == 3)
                gsWarn << "Geometry 3 is only 2D!\n";

            geoStr = "profile2D";
            inputFile = geoStr + "_problem.xml";
            break;
            
        case 4:
            if (dim == 3)
                gsWarn << "Flapping beam geometry is only 2D!\n";
                
            geoStr = "flappingBeam";
            inputFile = geoStr + "_flow.xml";
            break;
    }

    gsInfo << "Reading problem definition from file:\n" << inputFile << "\n\n";

    std::string path = gsFileManager::find(inputFile);
    if ( path.empty() )
    {
        gsWarn<<"Input file not found, quitting.\n";
        return 1;
    }

    gsFileData<> fd(inputFile);
    fd.getId(7, patches);   // id=0: multipatch domain
    fd.getId(1, f);         // id=1: source function
    fd.getId(2, bcInfo);    // id=2: boundary conditions

    gsInfo << "Solving Navier-Stokes problem in " << geoStr << " domain.\n";
    gsInfo << patches;
    gsInfo << "viscosity = " << viscosity << "\n";
    gsInfo << "source function = " << f << "\n";

    // ========================================= Define basis ========================================= 

    // Define discretization space by refining the basis of the geometry
    gsMultiBasis<> basis(patches);
    basis.degreeElevate(numElevate);

    switch(geo)
    {
        case 0:
            for (int r = 0; r < numRefine; ++r)
                basis.uniformRefine();
            break;

        case 1:
        default:
            refineBasis_step(basis, numRefine, 0, wallRefine, 0, 0, dim, 8.0, 2.0, 2.0); // 8, 2, 2 are dimensions of the domain in the input xml file
            break;

        case 2:
            refineBasis_cavity(basis, numRefine, wallRefine, dim);
            break;

        case 3:
            refineBasis_profile2D(basis, numRefine, wallRefine, leadRefine);
            break;
            
        case 4:
            // refine the flapping beam appropriately
            for (int r = 0; r < numRefine; ++r)
                basis.uniformRefine();
            break;
    }    

    std::vector< gsMultiBasis<> >  discreteBases;
    discreteBases.push_back(basis); // basis for velocity
    discreteBases.push_back(basis); // basis for pressure
    discreteBases[0].degreeElevate(1); // elevate the velocity space (Taylor-Hood element type)

    // ========================================= Solve ========================================= 

    gsNavStokesPde<real_t> NSpde(patches, bcInfo, &f, viscosity);
    gsFlowSolverParams<real_t> params(NSpde, discreteBases);
    params.options().setSwitch("quiet", quiet);
    params.options().setString("assemb.loop", matFormation);

    gsOptionList solveOpt;
    solveOpt.addInt("geo", "", geo);
    solveOpt.addInt("maxIt", "", maxIt);
    solveOpt.addInt("plotPts", "", plotPts);
    solveOpt.addInt("animStep", "", animStep);
    solveOpt.addInt("nonlin.maxIt", "", picardIt);
    solveOpt.addReal("tol", "", tol);
    solveOpt.addReal("picardTol", "", picardTol);
    solveOpt.addSwitch("plot", "", plot);
    solveOpt.addSwitch("animation", "", animation);
    solveOpt.addSwitch("plotMesh", "", plotMesh);
    solveOpt.addSwitch("stokesInit", "", stokesInit);
    solveOpt.addString("id", "", "");

    if (steady)
    {
        solveOpt.setString("id", "steady");
        params.options().setString("lin.solver", "direct");

        gsINSSolverSteady<real_t, ColMajor> NSsolver(params);

        gsInfo << "\n----------\n";
        gsInfo << "Solving the steady problem with direct linear solver.\n";

        solveProblem(NSsolver, solveOpt, geo);

        // example of flow rate computation
        if (geo == 1)
        {
            std::vector<std::pair<int, boxSide> > bndOut;
            bndOut.push_back(std::make_pair(0, boundary::east));
            bndOut.push_back(std::make_pair(1, boundary::east));
            gsField<> velocity = NSsolver.constructSolution(0);
            gsFlowBndEvaluator_flowRate<real_t> flowRateEval(params, bndOut);
            flowRateEval.setVelocityField(velocity);
            flowRateEval.evaluate();
            gsInfo << "bndOut flow rate = " << flowRateEval.getValue() << "\n";
        }
    }

    if (steadyIt)
    {
        solveOpt.setString("id", "steadyIt");
        params.options().setString("lin.solver", "iter");
        params.options().setInt("lin.maxIt", linIt);
        params.options().setReal("lin.tol", linTol);
        params.options().setString("lin.precType", precond);

        gsINSSolverSteady<real_t, ColMajor > NSsolver(params);

        gsInfo << "\n----------\n";
        gsInfo << "Solving the steady problem with preconditioned GMRES as linear solver.\n";
        gsInfo << "Used preconditioner: " << params.options().getString("lin.precType") << "\n";

        solveProblem(NSsolver, solveOpt, geo);

        gsFlowLinSystSolver_iter<real_t, ColMajor, gsGMRes<> >* linSolverPtr = dynamic_cast<gsFlowLinSystSolver_iter<real_t, ColMajor, gsGMRes<> >* >( NSsolver.getLinSolver() );
        reportLinIterations(linSolverPtr);
    }

    if (unsteady)
    {
        solveOpt.setString("id", "unsteady");
        params.options().setReal("timeStep", timeStep);
        params.options().setInt("nonlin.maxIt", picardIt);
        params.options().setReal("nonlin.tol", picardTol);
        params.options().setString("lin.solver", "direct");

        gsINSSolverUnsteady<real_t, ColMajor> NSsolver(params);

        gsInfo << "\n----------\n";
        gsInfo << "Solving the unsteady problem with direct linear solver.\n";

        solveProblem(NSsolver, solveOpt, geo);
    }

    if (unsteadyIt)
    {
        solveOpt.setString("id", "unsteadyIt");
        params.options().setReal("timeStep", timeStep);
        params.options().setInt("nonlin.maxIt", picardIt);
        params.options().setReal("nonlin.tol", picardTol);
        params.options().setString("lin.solver", "iter");
        params.options().setInt("lin.maxIt", linIt);
        params.options().setReal("lin.tol", linTol);
        params.options().setString("lin.precType", precond);
        // params.precOptions().setReal("gamma", 10); // parameter for AL preconditioner

        gsINSSolverUnsteady<real_t, ColMajor > NSsolver(params);

        gsInfo << "\n----------\n";
        gsInfo << "Solving the unsteady problem with preconditioned GMRES as linear solver.\n";
        gsInfo << "Used preconditioner: " << params.options().getString("lin.precType") << "\n";

        solveProblem(NSsolver, solveOpt, geo);
        
        gsFlowLinSystSolver_iter<real_t, ColMajor, gsGMRes<> >* linSolverPtr = dynamic_cast<gsFlowLinSystSolver_iter<real_t, ColMajor, gsGMRes<> >* >( NSsolver.getLinSolver() );
        reportLinIterations(linSolverPtr);
    }

    return 0; 
}

// ... 然后是 solveProblem 的定义 ...
template<class T, int MatOrder>
void solveProblem(gsINSSolver<T, MatOrder>& NSsolver, gsOptionList opt, int geo)
{
    gsStopwatch clock;

    // ------------------------------------
    // prepare strings for output filenames

    bool plot = opt.getSwitch("plot");
    std::string geoStr = "";
    std::string id = opt.getString("id");
    if (plot)
    {
        index_t dim = NSsolver.getParams()->getPde().domain().geoDim();
        std::string dimStr = util::to_string(dim) + "D";

        switch(opt.getInt("geo"))
        {
            case 0:
                geoStr = "customGeo";
                break;
            case 1:
                geoStr = "BFS" + dimStr;
                break;
            case 2:
                geoStr = "LDC" + dimStr;
                break;
            case 3:
                geoStr = "profile2D";
                break;
            case 4:
                geoStr = "flapping_beam" + dimStr;
                break;
            default:
                // 如果没有匹配的几何体ID，使用一个通用名称
                geoStr = "geo" + util::to_string(opt.getInt("geo")) + "_" + dimStr;
                break;
        }
    }

    // ------------------------------------
    // solve problem

    gsInfo << "\ninitialization...\n";
    NSsolver.initialize();

    gsInfo << "numDofs: " << NSsolver.numDofs() << "\n";

    gsINSSolverUnsteady<T, MatOrder>* pSolver = dynamic_cast<gsINSSolverUnsteady<T, MatOrder>*>(&NSsolver);

    
    if (pSolver)
    {
        if (opt.getSwitch("stokesInit"))
            pSolver->solveStokes();
        if (opt.getSwitch("animation"))
        {
            pSolver->solveWithAnimation(opt.getInt("maxIt"), opt.getInt("animStep"), 
                                        geoStr + "_" + id, opt.getReal("tol"), opt.getInt("plotPts"));
        }
        else
        {
            // create ParaView files for time step collection
            std::string fileNameU = geoStr + "_" + id + "_velocity_animation.pvd";
            std::ofstream fileU(fileNameU.c_str());
            GISMO_ASSERT(fileU.is_open(), "Error creating " << fileNameU);

            std::string fileNameP = geoStr + "_" + id + "_pressure_animation.pvd";
            std::ofstream fileP(fileNameP.c_str());
            GISMO_ASSERT(fileP.is_open(), "Error creating " << fileNameP);

            // use the existing functions in gsFlowUtils.h
            gismo::startAnimationFile(fileU);
            gismo::startAnimationFile(fileP);
            
            // determine the animation step
            int animStep = 5; 
            try {
                animStep = opt.getInt("animStep");
            } catch (...) {
                gsInfo << "Using default animation step: " << animStep << "\n";
            }
            
            // save the initial state
            if (opt.getSwitch("plot"))
            {
                gsField<T> velocity = pSolver->constructSolution(0);
                gsField<T> pressure = pSolver->constructSolution(1);
                
                std::string velocityBaseName = geoStr + "_" + id + "_velocity_step0";
                std::string pressureBaseName = geoStr + "_" + id + "_pressure_step0";
                
                gsWriteParaview<>(velocity, velocityBaseName, opt.getInt("plotPts"), opt.getSwitch("plotMesh"));
                gsWriteParaview<>(pressure, pressureBaseName, opt.getInt("plotPts"));
                
                // add references to the collection file
                int numPatches = NSsolver.getParams()->getPde().patches().nPatches();
                for (int p = 0; p < numPatches; p++)
                {
                    fileU << "<DataSet timestep=\"0\" part=\"" << p 
                          << "\" file=\"" << velocityBaseName << p << ".vts\"/>\n";
                    fileP << "<DataSet timestep=\"0\" part=\"" << p 
                          << "\" file=\"" << pressureBaseName << p << ".vts\"/>\n";
                }
            }
            
            // create temporary variables to store the previous solution
            gsVector<T> prevVelocityCoefs;
            gsVector<T> prevPressureCoefs;
            
            // get the initial coefficients
            if (opt.getSwitch("stokesInit")) {
                prevVelocityCoefs = pSolver->solutionCoefs(0);
                prevPressureCoefs = pSolver->solutionCoefs(1);
            }

            std::vector<FluidInterface> interfaces = {
                                {3, boundary::south},  // 流体patch 3的south边界 -> 梁的north边界 (上边)
                                {4, boundary::north},  // 流体patch 4的north边界 -> 梁的south边界 (下边)
                                {5, boundary::west},   // 流体patch 5的west边界 -> 梁的east边界 (右边)
                            };
            
            // 初始化结构求解器（只在flapping beam案例中）
            gsElasticityAssembler<T>* elasticityAssembler = nullptr;
            gsMassAssembler<T>* massAssembler = nullptr;
            gsElTimeIntegrator<T>* solidSolver = nullptr;
            gsMultiPatch<T> solidGeometry;
            gsMultiPatch<T> solidDisplacement;
            gsMultiBasis<T> solidBasis; // 保存基函数
            gsMultiPatch<T> initialFluidGeometry; // 保存初始流体几何
            // pressureLoadFunc 不再需要，压力现在通过gsPressureToTraction动态应用
            
            if (opt.getInt("geo") == 4) // flapping beam case
            {
                // 读取梁的几何
                std::string beamFile = gsFileManager::find("flappingBeam_beam.xml");
                gsInfo << "Beam file: " << beamFile << "\n";
                if (!beamFile.empty()) {
                    gsFileData<> fd(beamFile);
                    gsInfo << "Reading beam geometry...\n";
                    fd.dump();  // 打印文件内容
                    fd.getFirst<gsMultiPatch<>>(solidGeometry); // 使用getFirst而不是getId
                    
                    // 创建基函数
                    solidBasis = gsMultiBasis<T>(solidGeometry);
                    int numRefineStruct = 2; // 使用与流体相同的细化级别
                    for (int r = 0; r < numRefineStruct; ++r)
                        solidBasis.uniformRefine();
                    
                    // 边界条件：梁的左端固定
                    gsBoundaryConditions<T> solidBC;
                    solidBC.addCondition(0, boundary::west, condition_type::dirichlet, 0, 0);
                    solidBC.addCondition(0, boundary::west, condition_type::dirichlet, 0, 1);
                    
                    // 外力（初始为0）
                    gsConstantFunction<T> bodyForce(0., 0., 2);
                    
                    
                    // 创建弹性求解器
                    elasticityAssembler = new gsElasticityAssembler<T>(solidGeometry, solidBasis, solidBC, bodyForce);
                    elasticityAssembler->options().setReal("YoungsModulus", 1.4e6);
                    elasticityAssembler->options().setReal("PoissonsRatio", 0.4);
                    elasticityAssembler->options().setInt("MaterialLaw", material_law::saint_venant_kirchhoff);
                    
                    // 创建质量求解器
                    massAssembler = new gsMassAssembler<T>(solidGeometry, solidBasis, solidBC, bodyForce);
                    massAssembler->options().setReal("Density", 1.0e3);
                    
                    // 创建时间积分器
                    solidSolver = new gsElTimeIntegrator<T>(*elasticityAssembler, *massAssembler);
                    solidSolver->options().setInt("Scheme", time_integration::implicit_nonlinear);
                    solidSolver->options().setReal("Beta", 0.25);
                    solidSolver->options().setReal("Gamma", 0.5);
                    
                    gsInfo << "Initialized elasticity system with " << elasticityAssembler->numDofs() << " dofs.\n";
                    
                    // 初始化位移场
                    // 初始化位移场为零
                    solidDisplacement = solidGeometry;
                    // 将位移设为0，但保持几何的控制点结构
                    for (size_t p = 0; p < solidDisplacement.nPatches(); ++p) {
                        gsMatrix<T> coefs = solidDisplacement.patch(p).coefs();
                        coefs.setZero();
                        solidDisplacement.patch(p).coefs() = coefs;
                    }
                }
                
                // 保存初始流体几何
                initialFluidGeometry = pSolver->getParams()->getPde().patches();
            }
            
            for (int i = 0; i < opt.getInt("maxIt"); ++i)
            {
                // 执行一个时间步
                pSolver->nextIteration();
                
                // 验证求解器状态
                GISMO_ASSERT(pSolver->getParams()->getPde().patches().nPatches() > 0, 
                            "Solver has empty patches after nextIteration");
                
                // 获取当前解的系数
                gsVector<T> currentVelocityCoefs = pSolver->solutionCoefs(0);
                gsVector<T> currentPressureCoefs = pSolver->solutionCoefs(1);

                // 移动边界 - 计算当前时间
                T currentTime = (i + 1) * pSolver->getParams()->options().getReal("timeStep");
                gsMultiPatch<T> currentPatches = pSolver->getParams()->getPde().patches();


                // FSI耦合
                if (solidSolver && opt.getInt("geo") == 4) 
                {
                    // 1. 获取压力场
                    gsField<T> pressureField = pSolver->constructSolution(1);
                    
                    // 保存当前求解器状态
                    gsMatrix<T> oldSolutionVector;
                    gsMatrix<T> oldVelocityVector;
                    if (i > 0) {  // 第一步没有旧解
                        oldSolutionVector = solidSolver->solutionVector();
                        oldVelocityVector = solidSolver->velocityVector();
                    }
                    
                    // 2. 创建流体-固体耦合边界条件
                    gsBoundaryConditions<T> newBC;
                    // 固定端边界条件
                    newBC.addCondition(0, boundary::west, condition_type::dirichlet, 0, 0);
                    newBC.addCondition(0, boundary::west, condition_type::dirichlet, 0, 1);
                    
                    // 添加压力牵引边界条件
                    // 获取当前变形后的梁几何
                    gsMultiPatch<T> deformedSolidGeometry = solidGeometry;
                    if (solidDisplacement.nPatches() > 0 && i > 0) {
                        gsMatrix<T> origCoefs = deformedSolidGeometry.patch(0).coefs();
                        gsMatrix<T> dispCoefs = solidDisplacement.patch(0).coefs();
                        if (origCoefs.rows() == dispCoefs.rows()) {
                            deformedSolidGeometry.patch(0).setCoefs(origCoefs + dispCoefs);
                        }
                    }
                    
                    // 定义耦合界面（梁的上、下、右边界）
                    std::vector<boundary::side> couplingInterfaces = {
                        boundary::north,  // 上边界
                        boundary::south,  // 下边界
                        boundary::east    // 右边界（自由端）
                    };
                    
                    // 使用 gsPressureToTraction 添加压力边界条件
                    if (pressureField.function().size() > 0) {
                        // 为每个耦合界面创建 gsPressureToTraction 实例
                        for (const auto& side : couplingInterfaces) {
                            // 创建压力到牵引力转换器
                            gsPressureToTraction<T>* pressureToTraction = 
                                new gsPressureToTraction<T>(pressureField.function().function(0), solidGeometry.patch(0), side);
                            
                            // 添加为Neumann边界条件
                            newBC.addCondition(0, side, condition_type::neumann, pressureToTraction);
                            
                            gsInfo << "已为边界 " << side << " 添加 gsPressureToTraction\n";
                        }
                    }
                    
                    gsInfo << "已添加压力牵引边界条件，总边界条件数: " << newBC.size() << "\n";
                    
                    // 3. 重新创建装配器
                    gsConstantFunction<T> bodyForce(0., 0., 2);
                    delete elasticityAssembler;
                    elasticityAssembler = new gsElasticityAssembler<T>(solidGeometry, solidBasis, newBC, bodyForce);
                    elasticityAssembler->options().setReal("YoungsModulus", 1.4e6);
                    elasticityAssembler->options().setReal("PoissonsRatio", 0.4);
                    elasticityAssembler->options().setInt("MaterialLaw", material_law::saint_venant_kirchhoff);
                    
                    // 重新创建质量装配器
                    delete massAssembler;
                    massAssembler = new gsMassAssembler<T>(solidGeometry, solidBasis, newBC, bodyForce);
                    massAssembler->options().setReal("Density", 1.0e3);
                    
                    // 重新创建时间积分器
                    delete solidSolver;
                    solidSolver = new gsElTimeIntegrator<T>(*elasticityAssembler, *massAssembler);
                    solidSolver->options().setInt("Scheme", time_integration::implicit_nonlinear);
                    solidSolver->options().setReal("Beta", 0.25);
                    solidSolver->options().setReal("Gamma", 0.5);
                    
                    // 恢复旧的状态（如果存在）
                    if (i > 0 && oldSolutionVector.size() > 0) {
                        // 提取位移部分（solutionVector可能包含位移和压力）
                        index_t dispDofs = elasticityAssembler->numDofs();
                        gsMatrix<T> oldDisplacement = oldSolutionVector.topRows(dispDofs);
                        solidSolver->setDisplacementVector(oldDisplacement);
                        solidSolver->setVelocityVector(oldVelocityVector);
                    }
                    
                    // 4. 求解固体问题
                    gsInfo << "求解固体时间步...\n";
                    solidSolver->makeTimeStep(pSolver->getParams()->options().getReal("timeStep"));
                    
                    // 构造位移场
                    solidSolver->constructSolution(solidDisplacement);
                    
                    // 输出位移信息
                    T maxDisp = solidDisplacement.patch(0).coefs().cwiseAbs().maxCoeff();
                    gsInfo << "固体最大位移: " << maxDisp << "\n";
                    
                    // 保存梁动画数据
                    if (!beamAnimationInitialized) {
                        beamAnimationInitialized = true;
                        gsInfo << "初始化梁动画集合\n";
                    }
                    
                    // 计算应力场
                    gsPiecewiseFunction<> stresses;
                    elasticityAssembler->constructCauchyStresses(solidDisplacement, stresses, stress_components::von_mises);
                    
                    // 创建位移场和应力场
                    gsField<> displacementField(solidGeometry, solidDisplacement);
                    gsField<> stressField(solidGeometry, stresses, true);
                    
                    // 保存到Paraview文件（单个时间步）
                    real_t currentTime = i * pSolver->getParams()->options().getReal("timeStep");
                    std::string timeStr = util::to_string(currentTime);
                    std::string dispFileName = "beam_displacement_" + timeStr;
                    std::string stressFileName = "beam_stress_" + timeStr;
                    
                    gsWriteParaview<>(displacementField, dispFileName, 1000);
                    gsWriteParaview<>(stressField, stressFileName, 1000);
                    
                    // 添加到动画集合
                    beamDispCollection.addTimestep(dispFileName + "0", currentTime, ".vts");
                    beamStressCollection.addTimestep(stressFileName + "0", currentTime, ".vts");
                    
                    gsInfo << "已保存梁位移场到: " << dispFileName << "\n";
                    gsInfo << "已保存梁应力场到: " << stressFileName << "\n";
                    
                    // 5. 使用固体位移更新流体边界
                    updateGeometryBoundaryFromSolid(currentPatches, solidDisplacement, interfaces, initialFluidGeometry, solidGeometry);
                    
                    // 6. 构造速度场
                    // 使用与构造位移相同的方法来构造速度场
                    gsMultiPatch<T> solidVelocity = solidGeometry; // 复制几何结构
                    
                    // 获取速度向量
                    gsMatrix<T> velVector = solidSolver->velocityVector();
                    
                    // 使用elasticityAssembler的constructSolution方法来构造速度场
                    // 这与constructSolution(displacement)的原理相同
                    elasticityAssembler->constructSolution(velVector, 
                                                          elasticityAssembler->allFixedDofs(), 
                                                          solidVelocity);
                    
                    // 输出速度信息
                    T maxVel = solidVelocity.patch(0).coefs().cwiseAbs().maxCoeff();
                    gsInfo << "固体最大速度: " << maxVel << "\n";
                    
                    // // 输出几个控制点的速度值
                    // for (int k = 0; k < std::min(5, (int)solidVelocity.patch(0).coefs().rows()); ++k)
                    // {
                    //     gsInfo << "固体控制点 " << k << " 速度: " 
                    //            << solidVelocity.patch(0).coefs().row(k) << "\n";
                    // }
                    
                    // 先获取当前流体速度场
                    gsMultiPatch<real_t> fluidVelocity;
                    extractVelocityMultiPatch(*pSolver, fluidVelocity);
                    
                    // 更新边界速度
                    // 我们传递 solidDisplacement 而不是变形后的几何体
                    updateFluidBoundaryVelocityFromSolid(fluidVelocity, currentPatches, 
                                                        solidVelocity, solidGeometry, 
                                                        solidDisplacement, interfaces);
                    
                    // gsWriteParaview(fluidVelocity, "FluidVelocityWithBoundary");
                    
                    // 更新网格和求解器，传递更新后的速度场
                    resetSolverWithNewMesh(pSolver, currentPatches, &fluidVelocity);
                }
                // else
                // {
                //     // 没有固体耦合时，正常更新网格
                //     resetSolverWithNewMesh(pSolver, currentPatches);
                // }
                
                
                // Calculate solution change
                T relChange = 0;
                if (i > 0) // Only calculate change when mesh wasn't refined
                {
                    // Make sure dimensions match
                    if (currentVelocityCoefs.size() == prevVelocityCoefs.size() && 
                        currentPressureCoefs.size() == prevPressureCoefs.size())
                    {
                        // Calculate sum of squares of velocity and pressure changes
                        gsVector<T> velocityDiff = currentVelocityCoefs - prevVelocityCoefs;
                        gsVector<T> pressureDiff = currentPressureCoefs - prevPressureCoefs;
                        
                        T velocityNorm = velocityDiff.norm();
                        T pressureNorm = pressureDiff.norm();
                        T totalNorm = std::sqrt(velocityNorm*velocityNorm + pressureNorm*pressureNorm);
                        
                        T prevNorm = std::sqrt(prevVelocityCoefs.squaredNorm() + prevPressureCoefs.squaredNorm());
                        if (prevNorm > 1e-10)
                            relChange = totalNorm / prevNorm;
                        else
                            relChange = totalNorm;
                        
                        // gsInfo << "Time step " << i+1 << " solution change: " << relChange << "\n";
                    }
                    else
                    {
                        gsInfo << "Skip computing solution change due to dimension mismatch after mesh refinement.\n";
                    }
                }
                
                // Always update previous solution to ensure we can calculate change in next iteration
                prevVelocityCoefs = currentVelocityCoefs;
                prevPressureCoefs = currentPressureCoefs;
                
                if (opt.getSwitch("plot"))
                {
                    // Use the latest solution fields
                        gsField<T> velocity = pSolver->constructSolution(0);
                        gsField<T> pressure = pSolver->constructSolution(1);
                        
                        std::string velocityBaseName = geoStr + "_" + id + "_velocity_step" + util::to_string(i+1);
                        std::string pressureBaseName = geoStr + "_" + id + "_pressure_step" + util::to_string(i+1);
                        
                        gsWriteParaview<>(velocity, velocityBaseName, opt.getInt("plotPts"), opt.getSwitch("plotMesh"));
                        gsWriteParaview<>(pressure, pressureBaseName, opt.getInt("plotPts"));
                        
                        // Add references to the collection file
                        int numPatches = pSolver->getParams()->getPde().patches().nPatches();
                        for (int p = 0; p < numPatches; p++)
                        {
                            fileU << "<DataSet timestep=\"" << i+1 << "\" part=\"" << p 
                                  << "\" file=\"" << velocityBaseName << p << ".vts\"/>\n";
                            fileP << "<DataSet timestep=\"" << i+1 << "\" part=\"" << p 
                                  << "\" file=\"" << pressureBaseName << p << ".vts\"/>\n";
                        }
                }
            }
            
            // Close ParaView collection files
            gismo::endAnimationFile(fileU);
            gismo::endAnimationFile(fileP);
            
            // 保存梁动画文件
            if (beamAnimationInitialized && opt.getInt("geo") == 4) {
                beamDispCollection.save();
                beamStressCollection.save();
                gsInfo << "\n梁动画文件已保存:\n";
                gsInfo << "  - beam_displacement_animation.pvd\n";
                gsInfo << "  - beam_stress_animation.pvd\n";
            }
            
            // 清理梁求解器资源
            if (opt.getInt("geo") == 4) 
            {
                delete elasticityAssembler;
                delete massAssembler;
                delete solidSolver;
            }
            
            gsInfo << "\nSimulation completed " << opt.getInt("maxIt") << " time steps.\n";
            gsInfo << "ParaView animation files created: \n";
            gsInfo << "  " << fileNameU << "\n";
            gsInfo << "  " << fileNameP << "\n";
        }
    }
    else
    {
        NSsolver.solve(opt.getInt("maxIt"), opt.getReal("tol"), 0);
    }

    real_t totalT = clock.stop();

    gsInfo << "\nAssembly time:" << NSsolver.getAssemblyTime() << "\n";
    gsInfo << "Solve time:" << NSsolver.getSolveTime() << "\n";
    gsInfo << "Solver setup time:" << NSsolver.getSolverSetupTime() << "\n";
    gsInfo << "Total solveProblem time:" << totalT << "\n\n";

    // ------------------------------------
    // plot

    if (opt.getSwitch("plot")) 
    {
        try {
            gsField<> velocity = NSsolver.constructSolution(0);
            gsField<> pressure = NSsolver.constructSolution(1);
 
            int plotPts = opt.getInt("plotPts");
 
            gsInfo << "Plotting in Paraview...\n";
            gsWriteParaview<>(velocity, geoStr + "_" + id + "_velocity", plotPts, opt.getSwitch("plotMesh"));
            gsWriteParaview<>(pressure, geoStr + "_" + id + "_pressure", plotPts);
            // plotQuantityFromSolution("divergence", velocity, geoStr + "_" + id + "_velocityDivergence", plotPts);
        } catch (const std::exception &e) {
            gsInfo << "Error constructing solution for plotting: " << e.what() << "\n";
        }
    }
}

template<class T, int MatOrder>
void resetSolverWithNewMesh(gsINSSolverUnsteady<T, MatOrder>*& solver,
                           const gsMultiPatch<T>& newPatches,
                           const gsMultiPatch<T>* velocityWithBoundary)
{
    // 1. Save current solver parameters
    gsFlowSolverParams<T>* currentParams = solver->getParams().get();
    gsOptionList solverOptions = currentParams->options();
    T viscosity = currentParams->getPde().viscosity();
    const gsFunction<T>* f = currentParams->getPde().rhs();
    gsBoundaryConditions<> bcInfo = currentParams->getPde().bc();

    // 2. Save current solution (as fields)
    gsField<T> velocityFieldOld = solver->constructSolution(0);
    gsField<T> pressureFieldOld = solver->constructSolution(1);
    
    gsInfo << "Current dofs: " << solver->numDofs() << "\n";
    
    // Create deep copy of new patches to ensure their lifecycle - this is a key modification
    gsMultiPatch<T>* persistentPatches = new gsMultiPatch<T>(newPatches);
    
    // 确保patches拓扑信息是最新的
    persistentPatches->computeTopology();
    
    
    
    // 3. 使用原始的基函数，不创建新的
    // 保存原始基函数
    const std::vector<gsMultiBasis<T>> currentBases = solver->getAssembler()->getBases();
    
    // 复制原始基函数，而不是从几何创建新的
    std::vector<gsMultiBasis<T>> newBases;
    if (!currentBases.empty()) {
        // 使用原始的基函数
        newBases = currentBases;
        gsInfo << "使用原始基函数，保持自由度不变\n";
    } else {
        // 如果没有原始基函数，才从几何创建
        gsMultiBasis<T> basis(*persistentPatches);
        newBases.push_back(basis); // Basis for velocity
        newBases.push_back(basis); // Basis for pressure
    }
    
    // 验证基函数配置
    // gsInfo << "验证基函数配置...\n";
    // gsInfo << "基函数数量: " << newBases.size() << "\n";
    // if (!newBases.empty()) {
    //     gsInfo << "速度基函数patch数: " << newBases[0].nBases() << "\n";
    //     gsInfo << "压力基函数patch数: " << newBases[1].nBases() << "\n";
        
    //     // 打印每个patch的基函数大小
    //     for (size_t p = 0; p < newBases[0].nBases(); ++p) {
    //         const gsBasis<T>& vBasis = newBases[0].basis(p);
    //         const gsBasis<T>& pBasis = newBases[1].basis(p);
    //         gsInfo << "Patch " << p << " - 速度基函数大小: " << vBasis.size() 
    //                << ", 压力基函数大小: " << pBasis.size() << "\n";
    //     }
    // }
    
    // Elevate degree of velocity space (Taylor-Hood element type)
    // newBases[0].degreeElevate(1);
    
    // 4. Create new PDE and solver parameters
    // Use persistent patches to create PDE
    // 边界条件保持不变，因为速度边界信息已经包含在解的插值中
    gsNavStokesPde<T>* persistentPde = new gsNavStokesPde<T>(*persistentPatches, bcInfo, f, viscosity);
    
    // Create persistent solver parameters - these objects need to persist
    typename gsFlowSolverParams<T>::Ptr newParamsPtr =
        std::make_shared<gsFlowSolverParams<T>>(*persistentPde, newBases);
    newParamsPtr->options() = solverOptions;
    
    // 5. Create new solver instance - fix truncation issue here
    auto* newSolver = new gsINSSolverUnsteady<T, MatOrder>(newParamsPtr);
    
    // Initialize new solver
    newSolver->initialize();
    
    // Print number of DOFs and verify basis/geometry consistency
    gsInfo << "New dofs: " << newSolver->numDofs() << "\n";
    gsInfo << "New patches: " << persistentPatches->nPatches() << "\n";
    gsInfo << "New bases[0] pieces: " << newSolver->getAssembler()->getBases()[0].nBases() << "\n";
    gsInfo << "New bases[1] pieces: " << newSolver->getAssembler()->getBases()[1].nBases() << "\n";

    // Ensure consistency
    GISMO_ASSERT(newSolver->getAssembler()->getBases()[0].nBases() == persistentPatches->nPatches(), 
                 "Inconsistency between bases[0] and patches");
    GISMO_ASSERT(newSolver->getAssembler()->getBases()[1].nBases() == persistentPatches->nPatches(), 
                 "Inconsistency between bases[1] and patches");

    // 6. Project old solution onto new mesh
    transferSolutionToNewMesh(newSolver, velocityFieldOld, pressureFieldOld, velocityWithBoundary);
    
    // 7. Verify new solver state
    gsInfo << "Verifying new solver state...\n";
    gsInfo << "New solver patch count: " << newSolver->getParams()->getPde().patches().nPatches() << "\n";
    GISMO_ASSERT(newSolver->getParams()->getPde().patches().nPatches() > 0, 
                "New solver has empty patches");
    
    // 8. Replace solver, maintaining pointer ownership
    gsINSSolverUnsteady<T, MatOrder>* oldSolver = solver;
    solver = newSolver;
    
    // 9. Final verification
    gsInfo << "Final verification, solver patch count: " << solver->getParams()->getPde().patches().nPatches() << "\n";
    GISMO_ASSERT(solver->getParams()->getPde().patches().nPatches() > 0, 
                "Final solver has empty patches");
    
    // Note: We don't delete oldSolver in case it's externally managed
    // We also don't delete persistentPatches and persistentPde as they're managed by the solver
}

template<class T, int MatOrder>
void transferSolutionToNewMesh(gsINSSolverUnsteady<T, MatOrder>* solver,
                              const gsField<T>& velocityField,
                              const gsField<T>& pressureField,
                              const gsMultiPatch<T>* velocityWithBoundary)
{
    // 获取新的基函数和补丁
    const std::vector<gsMultiBasis<T>>& newBases = solver->getAssembler()->getBases();
    const gsMultiPatch<T>& newPatches = solver->getParams()->getPde().patches();

    // 添加调试信息，检查一致性
    gsDebugVar(newPatches.nPatches());
    gsDebugVar(newBases.size());
    for (size_t i = 0; i < newBases.size(); ++i) {
        gsDebugVar(newBases[i].nBases());
    }
    
    // 获取目标维度和自由度数量
    const index_t vDim = velocityField.function(0).targetDim();
    const index_t fullUdofs = solver->getAssembler()->getUdofs();
    const index_t tarDim = solver->getParams()->getPde().domain().geoDim();
    const index_t pShift = tarDim * fullUdofs;
    
    // 创建与setSolutionCoefs期望的尺寸匹配的矩阵
    gsMatrix<T> newVelocityCoefs(pShift, 1);
    gsMatrix<T> newPressureCoefs(solver->numDofs() - pShift, 1);
    
    newVelocityCoefs.setZero();
    newPressureCoefs.setZero();
    
    // 对速度场进行准插值
    gsQuasiInterpolate<T> quasiInterp;
    
    // 获取映射器
    const std::vector<gsDofMapper>& mappers = solver->getAssembler()->getMappers();
    
    // 决定使用哪个速度场进行插值
    bool useUpdatedVelocity = (velocityWithBoundary != nullptr);
    
    // 对每个patch进行插值
    for (size_t p = 0; p < newPatches.nPatches(); ++p)
    {
        if (p >= newBases[0].nBases()) {
            gsInfo << "Invalid patch index " << p << " for velocity basis. Skipping." << "\n";
            continue;
        }
        

        // 获取当前patch的基函数
        const gsBasis<T>& vBasis = newBases[0].basis(p);
        
        // 选择使用的速度场
        const gsFunction<T>& velFunc = useUpdatedVelocity ? 
                                       velocityWithBoundary->patch(p) : 
                                       velocityField.function(p);
        
        for (size_t i = 0; i < vBasis.size(); ++i)
        {
                // 对每个基函数进行插值
                gsMatrix<T> coef = quasiInterp.localIntpl(vBasis, velFunc, i);
                
                // 将系数存储到全局系数矩阵中 - 使用映射器获取全局索引
                if (mappers[0].is_free(i, p)) {
                    index_t globalIndex = mappers[0].index(i, p);
                    
                    for (index_t d = 0; d < vDim; ++d) {
                        newVelocityCoefs(globalIndex + d * fullUdofs, 0) = coef(0, d);
                    }
                }

        }
    }
    
    // 插值压力场
    for (size_t p = 0; p < newPatches.nPatches(); ++p)
    {
        if (p >= newBases[1].nBases()) {
            gsInfo << "Invalid patch index " << p << " for pressure basis. Skipping." << "\n";
            continue;
        }
        
        if (p >= pressureField.nPatches()) {
            gsInfo << "Skipping pressure interpolation for patch " << p << " as it does not exist in the old field.\n";
            continue;
        }
        
        // 获取当前patch的基函数
        const gsBasis<T>& pBasis = newBases[1].basis(p);
        
        for (size_t i = 0; i < pBasis.size(); ++i)
        {
            try {
                // 对每个基函数进行插值
                gsMatrix<T> coef = quasiInterp.localIntpl(pBasis, pressureField.function(p), i);
                
                // 将系数存储到全局系数矩阵中 - 使用映射器获取全局索引
                if (mappers[1].is_free(i, p)) {
                    index_t globalIndex = mappers[1].index(i, p);
                    newPressureCoefs(globalIndex, 0) = coef(0, 0);
                }
            } catch (const std::exception& e) {
                gsInfo << "Pressure field interpolation error: " << e.what() << " on patch " << p << " basis function " << i << "\n";
            }
        }
    }
    
    // 将投影后的系数设置为新解
    solver->setSolutionCoefs(newVelocityCoefs, 0);
    solver->setSolutionCoefs(newPressureCoefs, 1);
    
    // 应用固体边界速度（如果有边界速度数据）
    if (!boundaryVelocities.empty()) {
        gsInfo << "=== 在transferSolutionToNewMesh中应用固体边界速度 ===\n";
        
        // 获取速度系数矩阵进行修改
        gsMatrix<T> modifiedVelocityCoefs = solver->solutionCoefs(0);
        
        // 获取速度基函数和映射器
        const std::vector<gsMultiBasis<T>>& bases = solver->getAssembler()->getBases();
        const std::vector<gsDofMapper>& mappers = solver->getAssembler()->getMappers();
        const gsMultiBasis<T>& velocityBasis = bases[0];
        const gsDofMapper& velocityMapper = mappers[0];
        
        const index_t vDim = 2; // 2D问题
        const index_t fullUdofs = solver->getAssembler()->getUdofs();
        
        // 与梁接触的边界
        struct BeamInterface {
            size_t patchIdx;
            boundary::side boundSide;
        };
        
        std::vector<BeamInterface> interfaces = 
        {
            {3, boundary::south},
            {4, boundary::north},
            {5, boundary::west},
        };
        
        // 为每个接触边界应用固体速度
        for (const auto& interface : interfaces) {
            int boundaryKey = interface.patchIdx * 10 + static_cast<int>(interface.boundSide);
            
            auto it = boundaryVelocities.find(boundaryKey);
            if (it == boundaryVelocities.end()) continue;
            
            const gsMatrix<T>& solidBoundaryVelocities = it->second;
            if (solidBoundaryVelocities.rows() == 0) continue;
            
            // 计算平均速度
            gsVector<T> avgSolidVelocity(vDim);
            avgSolidVelocity.setZero();
            for (index_t d = 0; d < vDim; ++d) {
                avgSolidVelocity(d) = solidBoundaryVelocities.col(d).mean();
            }
            
            gsInfo << "应用patch " << interface.patchIdx << " 边界平均速度: [" 
                   << avgSolidVelocity.transpose() << "] m/s\n";
            
            // 获取边界上的基函数
            if (interface.patchIdx >= velocityBasis.nBases()) continue;
            
            const gsBasis<T>& basis = velocityBasis.basis(interface.patchIdx);
            if (basis.dim() != 2) continue;
            
            index_t rows = basis.component(0).size();
            index_t cols = basis.component(1).size();
            
            std::vector<index_t> boundaryBasisIndices;
            
            // 根据边界类型确定边界上的基函数索引
            // G+Smo 使用列优先（column-major）索引：index = i + j * rows
            switch(interface.boundSide) {
                case boundary::west:  // 左边界：j=0, 所有行
                    for (index_t i = 0; i < rows; ++i) {
                        boundaryBasisIndices.push_back(i + 0 * rows);  // i + 0
                    }
                    break;
                case boundary::east:  // 右边界：j=cols-1, 所有行
                    for (index_t i = 0; i < rows; ++i) {
                        boundaryBasisIndices.push_back(i + (cols-1) * rows);
                    }
                    break;
                case boundary::south:  // 下边界：i=0, 所有列
                    for (index_t j = 0; j < cols; ++j) {
                        boundaryBasisIndices.push_back(0 + j * rows);  // j * rows
                    }
                    break;
                case boundary::north:  // 上边界：i=rows-1, 所有列
                    for (index_t j = 0; j < cols; ++j) {
                        boundaryBasisIndices.push_back((rows-1) + j * rows);
                    }
                    break;
                default:
                    continue;
            }
            
            // 应用速度到边界基函数
            for (size_t k = 0; k < boundaryBasisIndices.size(); ++k) {
                index_t localIdx = boundaryBasisIndices[k];
                
                if (velocityMapper.is_free(localIdx, interface.patchIdx)) {
                    index_t globalIdx = velocityMapper.index(localIdx, interface.patchIdx);
                    
                    for (index_t d = 0; d < vDim; ++d) {
                        index_t coeffIdx = globalIdx + d * fullUdofs;
                        
                        if (coeffIdx < modifiedVelocityCoefs.rows()) {
                            T velocityValue = avgSolidVelocity(d);
                            
                            // 如果有具体的边界点速度，使用插值
                            if (k < (size_t)solidBoundaryVelocities.rows() && d < solidBoundaryVelocities.cols()) {
                                velocityValue = solidBoundaryVelocities(k, d);
                            }
                            
                            modifiedVelocityCoefs(coeffIdx, 0) = velocityValue;
                        }
                    }
                }
            }
        }
        
        // 设置修改后的速度系数
        solver->setSolutionCoefs(modifiedVelocityCoefs, 0);
        gsInfo << "固体边界速度已应用\n";
    }

    gsDebugVar(newVelocityCoefs.size());
    gsDebugVar(newPressureCoefs.size());
    // 删除或注释掉以下行，避免在此时构建解
    // gsField<T> velocityResult = solver->constructSolution(0);
    // gsField<T> pressureResult = solver->constructSolution(1);
    // gsWriteParaview<>(velocityResult, "velocityResult", 1000, false);
    // gsWriteParaview<>(pressureResult, "pressureResult", 1000, false);

    gsInfo << "Projected solution to new mesh\n";
}

template<class T, int MatOrder>
void extractVelocityMultiPatch(gsINSSolverUnsteady<T, MatOrder>& solver,
                              gsMultiPatch<T>& velocityMP)
{
    // 获取速度场
    gsField<T> velField = solver.constructSolution(0);
    
    // 清空输出
    velocityMP.clear();
    
    // 如果场是参数化的，提取几何体
    if (velField.isParametrized())
    {
        for (int i = 0; i < velField.nPieces(); ++i)
        {
            velocityMP.addPatch(velField.igaFunction(i).clone());
        }
    }
}

template<class T>
void updateFluidBoundaryVelocityFromSolid(gsMultiPatch<T>& fluidVelocity,
                                          const gsMultiPatch<T>& fluidGeometry,
                                          const gsMultiPatch<T>& solidVelocity,
                                          const gsMultiPatch<T>& solidReferenceGeometry,
                                          const gsMultiPatch<T>& solidDisplacement,
                                          const std::vector<FluidInterface>& interfaces)
{
    
    // 获取固体的各个场（只有一个patch - 梁）
    const gsGeometry<T>& solidVelGeom = solidVelocity.patch(0);
    const gsGeometry<T>& solidRefGeom = solidReferenceGeometry.patch(0);
    const gsGeometry<T>& solidDispGeom = solidDisplacement.patch(0);
    
    // 遍历所有流固界面
    for (const FluidInterface& iface : interfaces)
    {

        gsGeometry<T>& fluidVelGeom = fluidVelocity.patch(iface.patchIdx);
        const gsGeometry<T>& fluidGeom = fluidGeometry.patch(iface.patchIdx);
        
        // 获取该边界的基函数
        const gsBasis<T>& basis = fluidGeom.basis();
        gsMatrix<index_t> bndDofs = basis.boundary(iface.boundarySide);
        
        gsInfo << "边界控制点数: " << bndDofs.cols() << "\n";
        
        // 获取速度场的控制点
        gsMatrix<T>& velCoefs = fluidVelGeom.coefs();
        
        // 如果边界控制点太少，在边界上采样更多点
        index_t numSamplePoints = std::max(index_t(10), bndDofs.cols()); // 至少采户10个点
        if (bndDofs.cols() < 5) {
            gsInfo << "边界控制点太少，将在边界上采样 " << numSamplePoints << " 个点\n";
        }
        
        // 创建一个存储边界速度的容器
        gsMatrix<T> boundaryVelMatrix(numSamplePoints, 2); // 每行是一个边界点的速度
        
        // 获取边界几何
        std::unique_ptr<gsGeometry<T>> boundaryGeom = fluidGeom.boundary(iface.boundarySide);
        
        // 在边界上采样点
        for (index_t i = 0; i < numSamplePoints; ++i)
        {
            // 计算参数空间中的位置 (0到1之间均匀分布)
            T param = i / T(numSamplePoints - 1);
            gsMatrix<T> boundaryParam(1, 1);
            boundaryParam(0, 0) = param;
            
            // 评估边界上的物理坐标
            gsMatrix<T> physicalPtMat;
            boundaryGeom->eval_into(boundaryParam, physicalPtMat);
            gsVector<T> physicalPt = physicalPtMat.col(0);
            
            // 在参考配置上找最近点
            gsVector<T> paramPt;

            // 构造当前变形后的梁几何：clone 一份，再加上位移系数
            std::unique_ptr< gsGeometry<T> > defSolidPtr( solidRefGeom.clone() );

            // 若位移场与参考几何控制点布局一致，则直接逐系数相加
            const gsMatrix<T>& refCoefs  = solidRefGeom.coefs();
            const gsMatrix<T>& dispCoefs = solidDispGeom.coefs();

            if (refCoefs.rows() == dispCoefs.rows() && refCoefs.cols() == dispCoefs.cols())
            {
                defSolidPtr->setCoefs( refCoefs + dispCoefs );
            }
            else
            {
                // 尺寸不匹配时，暂时仅使用参考几何，避免维度断言失败
                gsWarn << "[updateFluidBoundaryVelocityFromSolid] Warning: displacement coefficients size "
                       << dispCoefs.rows() << "x" << dispCoefs.cols()
                       << " does not match reference geometry (" << refCoefs.rows() << "x" << refCoefs.cols() << "). Skipping addition.\n";
                defSolidPtr->setCoefs( refCoefs );
            }

            // 在变形后几何上寻找最近点
            defSolidPtr->closestPointTo(physicalPt, paramPt, 1e-6, false);

            // 评估该参数点处的速度（仍在 solidVelGeom 上，因为速度与参考参数一致）
            gsMatrix<T> vel;
            solidVelGeom.eval_into(paramPt, vel);       // 取速度
            
            // // 检查参数点是否在梁的固定端附近
            // if (i == 0 || i == bndDofs.cols()-1) {
            //     gsInfo << "参数点 " << paramPt.transpose() << " (参数空间)\n";
            //     gsInfo << "梁参数范围: " << solidRefGeom.support() << "\n";
            // }
            
            // 评估该参数点处的位移
            gsMatrix<T> disp;
            solidDispGeom.eval_into(paramPt, disp);
            
            // 计算变形后的位置
            gsMatrix<T> refPt;
            solidRefGeom.eval_into(paramPt, refPt);
            gsVector<T> deformedPt = refPt.col(0) + disp.col(0);
            
            // 计算到变形后位置的实际距离
            T actualDist = (physicalPt - deformedPt).norm();
            
            // 调试信息
            if (i == 0) // 只打印第一个点的信息
            {
                gsInfo << "Point " << i << ": physicalPt = " << physicalPt.transpose() 
                       << ", paramPt = " << paramPt.transpose() << "\n";
                gsInfo << "Reference point: " << refPt.transpose() 
                       << ", displacement: " << disp.transpose() << "\n";
                gsInfo << "Deformed point: " << deformedPt.transpose() 
                       << ", actual distance: " << actualDist << "\n";
            }
            
            // 评估该参数点处的速度
            // gsMatrix<T> vel;
            solidVelGeom.eval_into(paramPt, vel);
            
            // 调试：检查固体速度场的控制点
            if (i == 0 || i == bndDofs.cols()-1)  // 打印第一个和最后一个点
            {
                gsInfo << "Solid velocity at paramPt " << paramPt.transpose() << ": " << vel.transpose() << "\n";
                if (i == 0) {
                    gsInfo << "Solid velocity coefs max: " << solidVelGeom.coefs().cwiseAbs().maxCoeff() << "\n";
                    gsInfo << "Solid velocity coefs range: [" << solidVelGeom.coefs().minCoeff() 
                           << ", " << solidVelGeom.coefs().maxCoeff() << "]\n";
                }
            }
                
            // 存储边界速度
            boundaryVelMatrix(i, 0) = vel(0, 0); // x方向速度
            boundaryVelMatrix(i, 1) = vel(1, 0); // y方向速度
            
            // 更新速度场的控制点
            // 只更新边界上的控制点，保持内部流体速度不变
            if (i < bndDofs.cols()) {
                index_t idx = bndDofs(0, i);
                // 保存原始速度以便混合（如果需要）
                T originalVelX = velCoefs(idx, 0);
                T originalVelY = velCoefs(idx, 1);
                
                // 直接设置为固体速度（强制边界条件）
                velCoefs(idx, 0) = vel(0, 0); // x方向速度
                velCoefs(idx, 1) = vel(1, 0); // y方向速度
                
            }
        }
        
        // 存储到全局映射中，使用patch索引和边界标识作为键
        int boundaryKey = iface.patchIdx * 10 + static_cast<int>(iface.boundarySide);
        boundaryVelocities[boundaryKey] = boundaryVelMatrix;
        
        // 输出边界速度信息
        T maxBndVel = boundaryVelMatrix.cwiseAbs().maxCoeff();
        T avgBndVel = boundaryVelMatrix.cwiseAbs().mean();
        gsInfo << "界面 " << iface.patchIdx << " 最大边界速度: " << maxBndVel 
               << ", 平均边界速度: " << avgBndVel << "\n";
        gsInfo << "边界速度已保存，键值: " << boundaryKey << ", 大小: " 
               << boundaryVelMatrix.rows() << "x" << boundaryVelMatrix.cols() << "\n";
        
        // 检查是否所有速度都为零
        if (maxBndVel < 1e-10) {
            gsInfo << "警告：界面 " << iface.patchIdx << " 的所有边界速度接近零\n";
            // 打印几个样本参数点
            gsInfo << "样本参数点范围：\n";
            for (index_t j = 0; j < std::min(index_t(3), bndDofs.cols()); ++j) {
                gsVector<T> pt = fluidGeom.coefs().row(bndDofs(0, j)).transpose();
                gsInfo << "  点 " << j << ": " << pt.transpose() << "\n";
            }
        }
    }
    
    // 注意：实际的边界条件更新需要在resetSolverWithNewMesh中处理
    // 因为边界条件是PDE的一部分，需要重新创建求解器
    gsInfo << "流体边界速度已更新\n";
}

template<class T>
void updateGeometryBoundaryFromSolid(gsMultiPatch<T>& patches, 
                                     const gsMultiPatch<T>& solidDisplacement,
                                     const std::vector<FluidInterface>& interfaces,
                                     const gsMultiPatch<T>& initialFluidGeometry,
                                     const gsMultiPatch<T>& solidReferenceGeometry)
{
    gsInfo << "\n=== 更新流体边界几何 ===\n";
    
    // 首先打印当前patch的大小
    gsInfo << "更新前的patch大小:\n";
    for (size_t i = 0; i < patches.nPatches(); ++i) {
        const gsBasis<T>& basis = patches.patch(i).basis();
        gsInfo << "  Patch " << i << ": " << basis.size() << " 控制点\n";
    }
    
    // 获取固体位移场和参考几何（只有一个patch - 梁）
    const gsGeometry<T>& solidDispGeom = solidDisplacement.patch(0);
    const gsGeometry<T>& solidRefGeom = solidReferenceGeometry.patch(0);
    
    // 打印固体位移信息
    T maxSolidDisp = solidDispGeom.coefs().cwiseAbs().maxCoeff();
    gsInfo << "固体位移场最大值: " << maxSolidDisp << "\n";
    
    // 遍历所有流固界面
    for (const FluidInterface& iface : interfaces)
    {
        gsInfo << "\n处理流体patch " << iface.patchIdx << ", 边界 " << iface.boundarySide << "\n";
        
        gsGeometry<T>& fluidGeom = patches.patch(iface.patchIdx);
        
        // 获取该边界的基函数
        const gsBasis<T>& basis = fluidGeom.basis();
        gsInfo << "Patch基函数维度: " << basis.dim() << ", 大小: " << basis.size() << "\n";
        
        gsMatrix<index_t> bndDofs = basis.boundary(iface.boundarySide);
        
        // 注意：bndDofs可能是列向量，需要检查维度
        index_t numBoundaryDofs = (bndDofs.rows() > bndDofs.cols()) ? bndDofs.rows() : bndDofs.cols();
        gsInfo << "边界控制点数: " << numBoundaryDofs << "\n";
        gsInfo << "边界DOFs矩阵大小: " << bndDofs.rows() << " x " << bndDofs.cols() << "\n";
        gsInfo << "边界DOFs: " << bndDofs.transpose() << "\n";
        
        // 获取流体边界控制点
        gsMatrix<T>& fluidCoefs = fluidGeom.coefs();
        
        // 保存原始控制点位置
        gsMatrix<T> origCoefs = fluidCoefs;
        
        index_t updatedPoints = 0;
        T totalDisplacement = 0.0;
        
        // 获取初始流体几何的控制点（用于寻找对应关系）
        const gsGeometry<T>& initialFluidGeom = initialFluidGeometry.patch(iface.patchIdx);
        const gsMatrix<T>& initialFluidCoefs = initialFluidGeom.coefs();
        
        // 如果控制点太少，在边界上采样更多点
        if (numBoundaryDofs < 5) {
            gsInfo << "控制点太少，将在边界上采样更多点进行位移插值\n";
            
            // 获取边界几何
            std::unique_ptr<gsGeometry<T>> boundaryGeom = initialFluidGeom.boundary(iface.boundarySide);
            
            gsInfo << "边界几何维度: domainDim=" << boundaryGeom->domainDim() 
                   << ", targetDim=" << boundaryGeom->targetDim() << "\n";
            
            // 在边界上采样
            index_t numSamplePoints = 20; // 采样20个点
            // 注意：eval_into期望参数按列排列，每列是一个评估点
            gsMatrix<T> boundaryParams(boundaryGeom->domainDim(), numSamplePoints);
            
            if (boundaryGeom->domainDim() == 1) {
                for (index_t i = 0; i < numSamplePoints; ++i) {
                    boundaryParams(0, i) = i / T(numSamplePoints - 1);
                }
            } else {
                gsWarn << "边界几何的参数维度不是1，可能存在问题\n";
            }
            
            gsInfo << "边界参数矩阵大小: " << boundaryParams.rows() << " x " << boundaryParams.cols() << "\n";
            
            // 评估边界上的物理坐标
            gsMatrix<T> boundaryPoints;
            try {
                boundaryGeom->eval_into(boundaryParams, boundaryPoints);
            } catch (const std::exception& e) {
                gsWarn << "边界评估失败: " << e.what() << "\n";
                // 尝试转置参数矩阵
                gsInfo << "尝试转置参数矩阵...\n";
                boundaryGeom->eval_into(boundaryParams.transpose(), boundaryPoints);
            }
            
            // 收集所有边界点的位移
            gsMatrix<T> displacements(2, numSamplePoints);
            displacements.setZero();
            index_t validSamples = 0;
            
            for (index_t i = 0; i < numSamplePoints; ++i) {
                gsVector<T> samplePt = boundaryPoints.col(i);
                
                // 由于solidDispGeom只是位移场，我们应该使用原始梁几何来找最近点
                // 暂时简化处理：假设流体边界点都在梁上
                gsVector<T> paramPt;
                solidDispGeom.closestPointTo(samplePt, paramPt, 1e-6);
                
                // 直接评估位移
                gsMatrix<T> disp;
                // 确保参数是列向量
                gsMatrix<T> paramMat = paramPt;
                if (paramMat.cols() != 1) {
                    paramMat.resize(paramPt.size(), 1);
                }
                solidDispGeom.eval_into(paramMat, disp);
                displacements.col(i) = disp.col(0);
                validSamples++;
                
                if (i % 5 == 0) { // 每5个点打印一次
                    gsInfo << "  采样点 " << i << ": 位置=" << samplePt.transpose() 
                           << ", 位移=" << disp.transpose() << "\n";
                }
            }
            
            gsInfo << "在 " << numSamplePoints << " 个采样点中找到 " << validSamples << " 个有效点\n";
            
            // 使用采样的位移来更新控制点
            // 对每个控制点，找最近的采样点的位移
            for (index_t i = 0; i < numBoundaryDofs; ++i) {
                index_t idx = (bndDofs.rows() > bndDofs.cols()) ? bndDofs(i, 0) : bndDofs(0, i);
                gsVector<T> initialPt = initialFluidCoefs.row(idx).transpose();
                
                // 将控制点映射到边界参数
                gsVector<T> boundParam(boundaryGeom->domainDim());
                T dist = boundaryGeom->closestPointTo(initialPt, boundParam, 1e-6);
                
                if (dist < 1e-3 && boundaryGeom->domainDim() == 1) {
                    // 找到最近的采样点
                    T minParamDist = 1e10;
                    index_t closestSample = 0;
                    for (index_t j = 0; j < numSamplePoints; ++j) {
                        T paramDist = std::abs(boundaryParams(0, j) - boundParam(0));
                        if (paramDist < minParamDist) {
                            minParamDist = paramDist;
                            closestSample = j;
                        }
                    }
                    
                    // 应用最近采样点的位移
                    gsVector<T> disp = displacements.col(closestSample);
                    if (disp.norm() > 1e-10) {
                        fluidCoefs(idx, 0) = initialPt(0) + disp(0);
                        fluidCoefs(idx, 1) = initialPt(1) + disp(1);
                        updatedPoints++;
                        totalDisplacement += disp.norm();
                        
                        gsInfo << "控制点 " << i << " 应用位移: " << disp.transpose() << "\n";
                    }
                }
            }
        } else {
            // 原始的控制点更新方法
            
            // 对每个边界控制点
            for (index_t i = 0; i < numBoundaryDofs; ++i)
            {
                index_t idx = (bndDofs.rows() > bndDofs.cols()) ? bndDofs(i, 0) : bndDofs(0, i);
                
                // 使用初始几何的控制点位置来查找对应的固体点
                gsVector<T> initialPt = initialFluidCoefs.row(idx).transpose();
                
                gsVector<T> paramPt;
                solidDispGeom.closestPointTo(initialPt, paramPt, 1e-6);

                {
                    // 评估该参数点处的位移
                    gsMatrix<T> disp;
                    // 确保参数是列向量（2x1）
                    gsMatrix<T> paramMat = paramPt;
                    if (paramMat.cols() != 1) {
                        paramMat.resize(paramPt.size(), 1);
                    }
                    solidDispGeom.eval_into(paramMat, disp);
                    
                    // 将流体控制点设置为初始位置加上位移
                    fluidCoefs(idx, 0) = initialPt(0) + disp(0, 0); // x方向位移
                    fluidCoefs(idx, 1) = initialPt(1) + disp(1, 0); // y方向位移
                    
                    updatedPoints++;
                    totalDisplacement += disp.norm();
                    
                    if (i < 3 || i == numBoundaryDofs-1) {
                        gsInfo << "    应用位移: " << disp.transpose() << "\n";
                        gsInfo << "    新位置: " << fluidCoefs.row(idx) << "\n";
                    }
                }
            }
        }
        
        gsInfo << "更新了 " << updatedPoints << "/" << numBoundaryDofs << " 个控制点\n";
        if (updatedPoints > 0) {
            gsInfo << "平均位移: " << totalDisplacement/updatedPoints << "\n";
        }
        
        // 检查控制点是否真的改变了
        T maxChange = (fluidCoefs - origCoefs).cwiseAbs().maxCoeff();
        gsInfo << "最大控制点变化: " << maxChange << "\n";
    }
    
    // 2. 在重新参数化之前，先确保patch接口兼容性
    // 注意：原始XML中patch 3和4在u方向有4个控制点，其他patch有3个
    gsInfo << "\n=== 检查patch接口兼容性 ===\n";
    
    // 保存原始的控制点数配置
    std::vector<std::pair<index_t, index_t>> originalSizes;
    for (size_t i = 0; i < patches.nPatches(); ++i) {
        const gsBasis<T>& basis = patches.patch(i).basis();
        // 对于张量积基函数，获取各个方向的大小
        if (basis.dim() == 2) {
            const gsTensorBasis<2,T>* tbasis = dynamic_cast<const gsTensorBasis<2,T>*>(&basis);
            if (tbasis) {
                index_t size_u = tbasis->component(0).size();
                index_t size_v = tbasis->component(1).size();
                originalSizes.push_back(std::make_pair(size_u, size_v));
                gsInfo << "Patch " << i << " 原始大小: " << size_u << "x" << size_v << "\n";
            } else {
                // 如果不是张量积基函数，使用总大小
                originalSizes.push_back(std::make_pair(basis.size(), 1));
                gsInfo << "Patch " << i << " 原始大小: " << basis.size() << " (非张量积)\n";
            }
        }
    }
    
    // 提取patch 3, 4, 5创建一个子集进行重新参数化
    gsMultiPatch<T> interfacePatches;
    std::vector<size_t> interfacePatchIndices = {0,1,2,3,4,5,6};

    gsInfo << "Got here \n";
    
    // 确保接口处的patch有相同的控制点数
    // 获取patch的接口信息
    if (patches.nInterfaces() > 0) {
        gsInfo << "检查并匹配接口处的控制点数...\n";
        
        // 遍历所有接口
        for (size_t i = 0; i < patches.nInterfaces(); ++i) {
            const boundaryInterface& iface = patches.interfaces()[i];
            
            // 获取两侧的patch和边界
            index_t patch1 = iface.first().patch;
            index_t patch2 = iface.second().patch;
            boxSide side1 = iface.first().side();
            boxSide side2 = iface.second().side();
            
            // 获取两个patch的基函数
            const gsBasis<T>& basis1 = patches.patch(patch1).basis();
            const gsBasis<T>& basis2 = patches.patch(patch2).basis();
            
            // 检查是否为张量积基函数
            const gsTensorBasis<2,T>* tbasis1 = dynamic_cast<const gsTensorBasis<2,T>*>(&basis1);
            const gsTensorBasis<2,T>* tbasis2 = dynamic_cast<const gsTensorBasis<2,T>*>(&basis2);
            
            if (tbasis1 && tbasis2) {
                // 获取接口方向的控制点数
                index_t dir1 = (side1.direction() == 0) ? 1 : 0; // 垂直于边界的方向
                index_t dir2 = (side2.direction() == 0) ? 1 : 0;
                
                index_t size1 = tbasis1->component(dir1).size();
                index_t size2 = tbasis2->component(dir2).size();
                
                if (size1 != size2) {
                    gsInfo << "接口 " << i << ": Patch " << patch1 << " (side " << side1 << ") 有 " << size1 
                           << " 个控制点, Patch " << patch2 << " (side " << side2 << ") 有 " << size2 
                           << " 个控制点 - 需要匹配\n";
                    
                    // TODO: 在这里添加节点插入代码来匹配控制点数
                    // 但是为了保持原始网格，我们暂时不做修改
                }
            }
        }
    }
    
    // 添加所有patch到interfacePatches
    for (size_t patchIdx : interfacePatchIndices) 
    {
        if (patchIdx < patches.nPatches()) {
            interfacePatches.addPatch(patches.patch(patchIdx));
        }
    }

    // gsMultiPatch<T> refinedPatches;
    // patches.patch(0) patches.patch(0).uniformRefine(1, 0);

    // 3. 应用参数化方法，但需要保持原始的控制点数
    if (interfacePatches.nPatches() > 0) {
        short_t geodim = interfacePatches.targetDim();

        gsMultiPatch<T> optResults;
        
        if (geodim == 2) 
        {
            try {
                gsInfo << "应用Barrier参数化...\n";
                
                // 首先对每个patch进行均匀细化，使其有足够的自由度
                for (size_t i = 0; i < interfacePatches.nPatches(); ++i) {
                    // 获取原始大小
                    if (i < originalSizes.size()) {
                        const gsBasis<T>& currentBasis = interfacePatches.patch(i).basis();
                        const gsTensorBasis<2,T>* tbasis = dynamic_cast<const gsTensorBasis<2,T>*>(&currentBasis);
                        
                        if (tbasis) {
                            index_t current_u = tbasis->component(0).size();
                            index_t current_v = tbasis->component(1).size();
                            index_t target_u = originalSizes[i].first;
                            index_t target_v = originalSizes[i].second;
                            
                            // 如果当前控制点数少于原始数量，需要细化
                            if (current_u < target_u || current_v < target_v) {
                                gsInfo << "Patch " << i << " 需要预细化: " 
                                       << current_u << "x" << current_v << " -> " 
                                       << target_u << "x" << target_v << "\n";
                                
                                // 创建临时几何体进行细化
                                gsTensorBSpline<2,T>* tspline = dynamic_cast<gsTensorBSpline<2,T>*>(&interfacePatches.patch(i));
                                if (tspline) {
                                    // 计算需要的均匀细化次数
                                    index_t refine_u = 0, refine_v = 0;
                                    index_t temp_u = current_u, temp_v = current_v;
                                    
                                    while (temp_u < target_u) {
                                        temp_u = 2 * temp_u - 1;
                                        refine_u++;
                                    }
                                    while (temp_v < target_v) {
                                        temp_v = 2 * temp_v - 1;
                                        refine_v++;
                                    }
                                    
                                    if (refine_u > 0) {
                                        tspline->uniformRefine(refine_u, 0);
                                    }
                                    if (refine_v > 0) {
                                        tspline->uniformRefine(refine_v, 1);
                                    }
                                }
                            }
                        }
                    }
                }
                
                gsBarrierPatch<2, real_t> opt(interfacePatches, false);
                opt.options().setInt("Verbose", 0); 
                opt.options().setInt("AAPreconditionType", 1);
                opt.options().setInt("ParamMethod", 1);
                
                opt.compute();
                optResults = opt.result();
                
                // 应用结果，只更新控制点位置
                gsInfo << "优化结果patch数: " << optResults.nPatches() << "\n";
                for (size_t i = 0; i < interfacePatchIndices.size() && i < optResults.nPatches(); ++i) {
                    size_t patchIdx = interfacePatchIndices[i];
                    
                    // 打印调试信息
                    gsInfo << "处理patch " << patchIdx << " (第" << i << "个)\n";
                    gsInfo << "  原始大小: " << patches.patch(patchIdx).basis().size() << "\n";
                    gsInfo << "  优化后大小: " << optResults.patch(i).basis().size() << "\n";
                    
                    // 只更新控制点位置，不替换整个patch
                    const gsMatrix<T>& optCoefs = optResults.patch(i).coefs();
                    gsMatrix<T>& currentCoefs = patches.patch(patchIdx).coefs();
                    
                    if (optCoefs.rows() == currentCoefs.rows()) {
                        // 大小匹配，只更新位置
                        currentCoefs = optCoefs;
                        gsInfo << "  控制点位置已更新\n";
                    } else {
                        gsWarn << "  警告：控制点数不匹配 (" << currentCoefs.rows() 
                               << " vs " << optCoefs.rows() << ")，跳过此patch\n";
                        // 不进行任何更新，保持原始结构
                    }
                }
                
                gsInfo << "Barrier参数化完成\n";
                
            } catch (const std::exception& e) {
                gsWarn << "2D Barrier参数化失败: " << e.what() << "\n";
            }
        }
    }
    
    // 确保更新了接口和边界定义
    patches.computeTopology();
    
    // 确保接口conforming
    // ensureConformingInterfaces(patches);
    
    // 打印更新后的patch大小
    gsInfo << "\n更新后的patch大小:\n";
    for (size_t i = 0; i < patches.nPatches(); ++i) {
        const gsBasis<T>& basis = patches.patch(i).basis();
        gsInfo << "  Patch " << i << ": " << basis.size() << " 控制点\n";
    }
    
    gsInfo << "几何边界更新完成\n";
}